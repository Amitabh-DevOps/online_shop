name: CI/CD Pipeline for Online Shop

# Trigger the workflow on pushes to the 'github-action' branch.
on:
  push:
    branches:
      - github-action

env:
  AWS_REGION: eu-west-1
  S3_BUCKET: github-actions-buckets-new
  DYNAMODB_TABLE: github-actions-dbs-new

jobs:
  ###########################################################################
  # Job 1: Configure Terraform Backend
  ###########################################################################
  terraform-backend:
    name: Configure Terraform Backend
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository.
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Setup Terraform CLI.
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      # Step 3: Configure AWS Credentials.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Step 4: Verify AWS CLI installation.
      - name: Check AWS CLI Version
        run: aws --version

      # Step 5: Test AWS Configuration by listing S3 buckets.
      - name: Testing Configuration
        run: aws s3 ls

      # Step 6: Check if the S3 Bucket exists.
      - name: Check if S3 Bucket Exists
        id: check_bucket
        run: |
          if aws s3api head-bucket --bucket "${{ env.S3_BUCKET }}" --region "${{ env.AWS_REGION }}" 2>/dev/null; then
            echo "Bucket exists"
            echo "CREATE_BACKEND=false" >> $GITHUB_ENV
          else
            echo "Bucket does not exist"
            echo "CREATE_BACKEND=true" >> $GITHUB_ENV
          fi

      # Step 7: Initialize the Terraform backend.
      - name: Initialize Backend
        run: terraform init
        working-directory: terraform/terraform_backend

      # Step 8: Validate Terraform configuration
      - name: Validate Terraform
        run: terraform validate
        working-directory: terraform/terraform_backend

      # Step 9: Plan Terraform changes
      - name: Plan Backend Configuration
        run: terraform plan -var="create_backend=$CREATE_BACKEND"
        working-directory: terraform/terraform_backend

      # Step 10: Apply the Terraform backend configuration.
      - name: Apply Backend Configuration
        run: terraform apply --auto-approve -var="create_backend=$CREATE_BACKEND"
        working-directory: terraform/terraform_backend

  ###########################################################################
  # Job 2: Provision Infrastructure Resources
  ###########################################################################
  terraform-resources:
    name: Provision Resources
    runs-on: ubuntu-latest
    needs: terraform-backend
    outputs:
      ec2_public_ip: ${{ steps.get-ec2-ip.outputs.ec2_ip }}
    steps:
      # Checkout the repository.
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Setup Terraform CLI.
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      # Configure AWS Credentials.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Verify AWS CLI installation.
      - name: Check AWS CLI Version
        run: aws --version

      # Debug: Check available Ubuntu AMIs
      - name: Debug - Check Available Ubuntu AMIs
        run: |
          echo "🔍 Checking available Ubuntu AMIs in ${{ env.AWS_REGION }}..."
          aws ec2 describe-images \
            --region ${{ env.AWS_REGION }} \
            --owners 099720109477 \
            --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-*" \
                      "Name=state,Values=available" \
                      "Name=architecture,Values=x86_64" \
            --query 'Images[0:5].[Name,ImageId,CreationDate]' \
            --output table || echo "Failed to fetch AMI list"

      # Initialize Terraform using the remote backend.
      - name: Initialize Resources with Backend
        run: terraform init
        working-directory: terraform/terraform_resources

      # Validate Terraform configuration
      - name: Validate Terraform
        run: terraform validate
        working-directory: terraform/terraform_resources

      # Execute Terraform plan to review changes.
      - name: Terraform Plan
        run: terraform plan -var="use_fallback_ami=true"
        working-directory: terraform/terraform_resources

      # Apply the Terraform changes.
      - name: Apply Terraform Changes
        run: terraform apply --auto-approve -var="use_fallback_ami=true"
        working-directory: terraform/terraform_resources

      # Capture the EC2 instance's public IP from Terraform outputs.
      - name: Get EC2 Public IP
        id: get-ec2-ip
        run: echo "ec2_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        working-directory: terraform/terraform_resources
  ###########################################################################
  # Job 3: Build & Push Docker Image to DockerHub
  ###########################################################################
  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform-resources
    steps:
      # Checkout the repository.
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Set up Docker Buildx for advanced build features.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to DockerHub using stored secrets.
      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Build and push the Docker image to DockerHub.
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/online-shop:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/online-shop:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
  ###########################################################################
  # Job 4: Deploy Application to EC2
  ###########################################################################
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [terraform-resources, docker]
    steps:
      # Checkout the repository.
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Configure AWS Credentials.
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Deploy the application to the EC2 instance.
      - name: Deploy to EC2
        run: |
          echo "Deploying to EC2 instance: ${{ needs.terraform-resources.outputs.ec2_public_ip }}"
          
          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Update system
          sudo apt-get update
          
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            sudo apt-get install -y docker.io
            sudo systemctl start docker
            sudo systemctl enable docker
            sudo usermod -aG docker ubuntu
          fi
          
          # Stop and remove existing container
          sudo docker stop online-shop || true
          sudo docker rm online-shop || true
          
          # Pull latest image
          sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/online-shop:latest
          
          # Run new container
          sudo docker run -d \
            --name online-shop \
            -p 80:3000 \
            --restart unless-stopped \
            ${{ secrets.DOCKERHUB_USERNAME }}/online-shop:latest
          
          echo "Deployment completed successfully!"
          EOF
          
          # Make script executable
          chmod +x deploy.sh
          
          # Copy and execute deployment script on EC2
          scp -i terraform/terraform_resources/github-action-key \
              -o StrictHostKeyChecking=no \
              deploy.sh ubuntu@${{ needs.terraform-resources.outputs.ec2_public_ip }}:/tmp/
          
          ssh -i terraform/terraform_resources/github-action-key \
              -o StrictHostKeyChecking=no \
              ubuntu@${{ needs.terraform-resources.outputs.ec2_public_ip }} \
              'bash /tmp/deploy.sh'
  ###########################################################################
  # Job 5: Health Check
  ###########################################################################
  health-check:
    name: Application Health Check
    runs-on: ubuntu-latest
    needs: [terraform-resources, deploy]
    steps:
      - name: Wait for Application to Start
        run: sleep 30

      - name: Health Check
        run: |
          EC2_IP="${{ needs.terraform-resources.outputs.ec2_public_ip }}"
          MAX_ATTEMPTS=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS"
            
            if curl -f -s "http://$EC2_IP" > /dev/null; then
              echo "✅ Application is healthy!"
              echo "🌐 Application URL: http://$EC2_IP"
              exit 0
            else
              echo "❌ Health check failed, retrying in 10 seconds..."
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          echo "❌ Application failed to start after $MAX_ATTEMPTS attempts"
          exit 1
